
# 함수 목록
<br/>

## hx711 초기화 및 실행 관련 함수

<br/>

- ### begin( ) 함수
```c++
begin ( unit8_t dataPin , unit8_t clockPin , bool fastProcessor= false )
```
<br/>

- 직접 대입방법(예를 들어 2번핀(DOUT)과 3번핀(SCK)을 연결했을때)
```c++
 begin( 2 , 3 , false );
 begin( 2 , 3 , true );
 ```
<br/>

 - 간접 대입방법(상수변수 또는 일반 변수명을 미리 정했을때)
```c++
const unit8_t HX711_DOUT = 2;
const unit8_t HX711_SCK = 3;
const bool FAST_PROCESSOR_FALSE = false;

begin( HX711_DOUT , HX711_SCK , FAST_PROCESSOR_FALSE );
```
<br/>

> 현재 gain(증폭율)은 128배로 고정되어 있다. 그래서 노이즈도 많은 들어온다.
> 128 , 64 , 32 의 gain(증폭)을 쓸 수 있는지부터 확인해야 한다.
> 증폭배율이 높으면 미세한 무게 변화 감지 , 노이즈가 많으며  , 
> 증폭배율이 낮으면 그 반대가 된다. <br/>
---
<br/>

- ### reset( ) 함수
```c++
reset ()
```
내부 상태(state)를 시작 상태로 초기화 한다.  
0.3.4부터는 전원 끄기 / 켜기 기능이 추가되었다.  
begin( ) 함수를 호출하면 내부적으로 reset() 함수가 호출되면서 초기화도 같이 된다.  

---
<br/>

- ### is_ready( ) 함수
 
```c++
is_ready ()
```
HX711이 데이터를 읽을 준비가 되었는지 확인한다.  
로드셀 모듈이 준비가 되면 DOUT 핀이 LOW를 출력하게 된다.  
그래서 다음과 같은 코드로 로드셀 상태체크가 가능하다.
```c++
if ( !is_ready() ) {
    // HX711이 준비가 되지 않았을때
    Serial.println("HX711 is not ready");
}
else {
    // HX711이 준비가 되었을때
    Serial.println("HX711 is ready");
}
```
만약에 삼항식 이용하여 한줄로 표현하고 싶으면 
```c++
Serial.println( is_ready() ? "HX711 is ready" : "HX711 is not ready" );
```
---

<br/>

- ### wait_ready( ) 함수
```c++
wait_ready(uint32_t ms= 0)
```
로드셀이 준비가 안되면 ( DOUT 핀이 HIGH를 출력하면 ) 인자로  
 받은 시간(ms)만큼 대기하고 다음 단계로 넘어간다.   
이건 로드셀 준비전에 다른 과정 인해 지연이 생길경우 사용하면 좋다.  
예를 들어  
```c++
wait_ready(1000);
```
이라고 하면 로드셀이 준비가 될때까지 1초간 대기한다.
하지만 숫자를 직접 넣는것보단
```c++
const int WAIT_READY_TIME = 1000;
wait_ready(WAIT_READY_TIME);
```
을 추천한다.

---
<br/>

- ### wait_ready_retry( ) 함수
```c++
wait_ready_retry(uint8_t retries= 3, uint32_t ms= 0)
```
로드셀이 준비가 안되면 ( DOUT 핀이 HIGH를 출력하면 ) 인자로  
 받은 시간(ms)만큼 대기 * 횟수만큼 시도를 한다.  
예를들어
```c++
wait_ready_retry(3, 1000);
```
이라고 하면 로드셀이 준비가 될때까지 3번 시도하면서 1초씩 대기한다.  
하지만 숫자를 직접 넣는것보단
```c++
const int RETRIES = 3;
const int WAIT_READY_TIME = 1000;
wait_ready_retry(RETRIES, WAIT_READY_TIME);
```
을 추천한다.

---
<br/>

- ### wait_ready_timeout( ) 함수
```c++
wait_ready_timeout(uint32_t timeout= 1000, uint32_t ms= 0)
```
이번엔 횟수 말고 일정 시간(timeout)마다 준비 상태를 확인 하고 안되었으면  
인자로 받은 시간(ms)만큼 대기한다.  
예를들어
```c++
wait_ready_timeout(1000, 1000);
```
이라고 하면 로드셀이 준비가 될때까지 1초마다 확인하면서 1초씩 대기한다.
하지만 숫자를 직접 넣는것보단
```c++
const int TIMEOUT = 1000;
const int WAIT_READY_TIME = 1000;
wait_ready_timeout(TIMEOUT, WAIT_READY_TIME);
```
을 추천한다.

---

<br/>

> ## 여기부터는 데이터를 읽어오는 함수들이다.
- ### read( ) 함수
```c++
read()
```
이 함수에 대해서 요약하자면  
 데이터 준비 신호를 대기한 후, 인터럽트를 비활성화하고,  
 데이터 바이트를 읽고, gain(증폭율) 및 채널 선택을 위해 클록 펄스를 조정하고,  
 인터럽트를 재활성화하고, 부호 확장을 수행한 다음 최종 값을 반환합니다.  
데이타 시트에 나온 설명을 기초로 내부 코딩되어 있다.  

---
<br/>

- ### read_average( ) 함수 
```c++
read_average(uint8_t times= 10)
```
여러 번의 측정을 평균하여 반환하는 역할을 합니다.  기본값은 10번 측정 후 평균을 반환합니다.  
특이한 점은 실행 중에  
```c++
yield() 
```
함수를 사용하여 다른 작업을 수행할 수 있습니다.  
yield() 함수는 Arduino와 같은 임베디드 시스템에서 멀티태스킹을 지원하기 위해 사용되는 함수입니다.  
이 함수는 현재 실행 중인 작업을 잠시 중단하고, 다른 작업이 실행될 수 있도록 CPU 제어를 양보합니다.  
이는 특히 여러 작업이 동시에 실행되어야 하는 상황에서 유용합니다.

---
<br/>

- ### read_median( ) 함수
```c++
read_median(uint8_t times= 7)
```

read_median 함수는 여러 번의 측정을 통해 중앙값을 계산하여 반환합니다.  
입력 값 검증을 통해 측정 횟수를 3에서 15 사이로 제한합니다.  
측정값을 배열에 저장하고, 배열을 정렬한 후 중앙값을 계산하여 반환합니다.  
yield() 함수를 사용하여 다른 작업이 실행될 수 있도록 합니다.  


내부적으로 측정 횟수가 15를 넘어가도 15까지만 측정하고, 3보다 작아도 3번을 측정합니다.  
그리고 측정 횟수가 홀수일때는 중앙값을 , 짝수일때는 중앙값의 평균을 반환합니다.  

---
<br/>

- ### read_medavg( ) 함수

```c++
read_medavg(uint8_t times= 7)
```
주어진 횟수 ( 최대 15 , 최저 3) 만큼 측정을 하고  
읽은 값들을 오름 차순으로 정렬한 후 1/4부터 3/4까지의 값들만 합계를 구한 후 평균을 반환한다.  
이 함수는 노이즈를 줄이고 더 정확한 값을 얻기 위해 중앙값을 사용합니다.

---
<br/>

- ### read_runavg( ) 함수

```c++
read_runavg(uint8_t times= 7 , float alpha= 0.5)
```
read_runavg 함수는 주어진 횟수(times)만큼 측정을 수행하고,  
지수 이동 평균(Exponential Moving Average, EMA)을 계산하여 반환합니다.  
이 함수는 노이즈를 줄이고 더 부드러운 값을 얻기 위해 사용됩니다.  
함수의 매개변수는 측정 횟수(times)와 가중치(alpha)입니다.

---

<br/>

## 4가지 측정 방법 비교

- read_average( ) 함수 => 단순하며 빠르지만 , 노이즈가 심하면 정확도가 떨어진다.
- read_median( ) 함수 => average보다 노이즈가 적고 정확도가 높다. , 비대칭적인 데이터에 적합하다.
- read_medavg( ) 함수 => 노이즈를 제거하면서 좀 더 안정된 평균을 제공한다.
- read_runavg( ) 함수 => 실시간 데이터 처리할때 유용하며 , 연속 데이터의 노이즈를 줄입니다.  
  
예를 들어 데이터 값중 노이즈 값이 많다면 read_median( )  또는 read_medavg( ) 함수를 사용하는것이 좋다.
실시간 그래프를 그릴때는 read_runavg( ) 함수를 사용해보는 것이 좋다.  

---
<br/>

## 모드 및 전환 함수들

아래 함수들은 다음과 같다.  
```c++
set_raw_mode(), set_average_mode(), set_median_mode(), set_medavg_mode(), set_runavg_mode()
```
는 _mode 변수를 설정하여 HX711 객체의 동작 모드를 변경합니다.  
이러한 함수들은 HX711 클래스의 동작 모드를 설정하고, 설정된 모드에 따라 데이터를 읽어오며,  
읽어온 데이터를 단위 변환하는 데 사용됩니다.
<br/>

```c++
set_raw_mode()
```

```c++
set_average_mode()
```

```c++
set_median_mode()
```

```c++
set_medavg_mode()
```

```c++
set_runavg_mode()
```

---
<br/>

- ### get_mode( ) 함수
```c++
unit8_t get_mode()
```
현재 HX711 객체의 현재 동작 모드를 반환합니다.

---
<br/>

- ### get_value( ) 함수
```c++
get_value(unit8_t times= 1)
```
각 사전 설정된 모드들에 따라서 값을 반환한다. 다만 최종값은 원시값 - offset 값이고 물리적인 단위로는 의미 없다.  
그래서 get_units( ) 함수를 사용하여 물리적인 단위로 변환해야 한다.  
예를 들어  get_value( ) 함수를 사용하여2000 이라는 값이 나왔다면  
이는 원시값이고 , 이를 물리적인 단위 ( 킬로그램 , 그램 등 ) 로 변환하려면  
아래 get_units( ) 함수를 사용해야 한다.

---
<br/>

- ### get_units( ) 함수

```c++
get_units(unit8_t times= 10)
```
10회 측정한 get_value() 함수의 각 모드에 따른 값을 받고 물리적인 단위(킬로그램 , 그램 등)로 변환하여 값을 반환한다.  
```c++
float HX711::get_units(uint8_t times)
{
  float units = get_value(times) * _scale;
  return units;
};
```
설명보단 코드로 보는게 이해하기 쉽다.  
_scale 는 캘리브레이션 영역에서 받아온 값이다.
---
<br/>

## 여기서부터는 보정 및 설정 함수들이다.
<br/>

아래 3가지 함수들은 테어 기능들과 관련이 있다.  
tare(테어)기능은 로드셀에서 무게를 0으로 설정하는 기능이다.  
특히 용기의 무게를 제거하기 위해 사용한다.  

- ### tare( ) 함수
```c++
tare(unit8_t times= 10)
```
tare 함수는 주어진 횟수(times)만큼 측정을 수행하고,  
측정값의 평균을 offset 값으로 설정합니다.  
이때 쓰이는 평균 측정 함수는 read_average( ) 함수입니다.
 
---
<br/>

- ### set_tare( ) 함수
```c++
set_tare()
```
set_tare 함수는 tare ( ) 함수에서 받은 offset 값을 물리적인 단위(킬로그램 , 그램 등)으로 변환 및 값을 반환해준다.  

---
<br/>

- ### tare_set( ) 함수
```c++
tare_set();
```
_offset 값이 0이 아니면 true를 반환하고, 0이면 false를 반환한다.  
이는 테어 값이 설정 되었는지 확인하는 함수이다.


```c++
set_gain(unit8_t gain = HX711_CHANNEL_A_GAIN_128, bool forced = false)
```

--- 
<br/>

## 여기서부터는 증폭율(gain) 설정 함수들이다.

```c++
bool set_gain(unit8_t gain = HX711_CHANNEL_A_GAIN_128, bool forced = false)
```
이 함수들은 HX711 로드 셀 증폭기의 게인을 설정하고 확인하는 데 매우 유용하며,  
다양한 환경과 조건에서 센서의 민감도를 조절하는 데 사용됩니다.  
활용 예>  
```c++
HX711.set_gain(HX711_CHANNEL_A_GAIN_128);  // 128배 증폭기로 설정

// 증폭기 게인을 설정하고 설정이 성공하면 "Gain set to 128"를 출력 , 실패하면 "Gain not set"을 출력
if (HX711.set_gain(HX711_CHANNEL_A_GAIN_128)) {
    Serial.println("Gain set to 128");
}
else {
    Serial.println("Gain not set");
}

// 강제로 게인을 설정하려면 
HX711.set_gain(HX711_CHANNEL_A_GAIN_128, true);  // false로 설정하면 강제로 설정하지 않음

// 64배 증폭기로 설정
HX711.set_gain(HX711_CHANNEL_A_GAIN_64);

// 32배 증폭기로 설정
HX711.set_gain(HX711_CHANNEL_A_GAIN_32);

```
---
<br/>

- ### get_gain( ) 함수
```c++
unit8_t get_gain()
```
이 함수는 HX711 객체의 현재 증폭기 게인을 반환합니다.  
활용 예>
```c++
Serial.print("Gain is set to ");
Serial.println(HX711.get_gain());

// 아니면 
unit8_t gain = HX711.get_gain();
Serial.print("Gain is set to ");
Serial.println(gain);
```

---
<br/>

## 여기서부터는 캘리브레이션 함수들이다.

- ### set_scale( ) 함수
```c++
set_scale(float scale = 1.0f)
```
스케일 팩터(계수값)을 설정하고  값에 따라서 false 또는 true를 반환한다.  
측정된 원시 데이터를 실제 무게로 변환하는 데 사용됩니다.  

---
<br/>

- ### get_scale( ) 함수
```c++
get_scale()
```
현재 설정된 스케일 팩터를 반환합니다.  
_scale 의 역수를 반환하여 원래 설정된 스케일 팩터값을 반환 합니다. 
즉 현재 스케일 팩터값을 확인할때 사용 됩니다.  
활용 예>
```c++
Serial.print("Scale is set to ");
Serial.println(HX711.get_scale());
```

---
<br/>

- ### set_offset( ) 함수
```c++
set_offset(long offset = 0)
```
오프셋 값을 설정합니다.  
오프셋 값은 테어값을 설정할때 사용되며 , 측정된 원시 데이터에서 이 값을 빼면 실제 무게를 얻을 수 있습니다.

---
<br/>

- ### get_offset( ) 함수
```c++
get_offset()
```
현재 설정된 오프셋 값을 반환합니다.  
활용 예>
```c++
Serial.print("Offset is set to ");
Serial.println(HX711.get_offset());
```

---
<br/>

- ### calibrate_scale( ) 함수
```c++
calibrate_scale(unit16_t weight, unit8_t times= 10)
```
이 함수는 주어진 weight 값 과 times 값을 기반으로 _scale 값을 계산하여 설정합니다.  
정확한 측정을 위해 로드셀을 보정하는데 쓰입니다.
활용 예>
```c++
HX711.calibrate_scale(1000, 10);  // 1000g으로 보정 , 측정 10회
```

---
<br/>

## 여기서부터는 전원 관련 함수들이다.
```c++
power_down()
```

```c++
power_up()
```
## 

## 여기서부터는 가격 관련 함수들이다.
```c++
get_pricing(uint8_t times= 1){return get_units(times) * _price; }
```
set_unit_price(float price = 1.0) { _price = price; } 함수에서 받은 개당 값을 기반으로 총 가격을 계산 및 반환한다.
```c++
set_unit_price(float price = 1.0) { _price = price; }
```
상품의 개당 가격을 설정합니다.
```c++
get_uint_price() { return _price; }
```
현재 설정된 개당 가격을 반환합니다.