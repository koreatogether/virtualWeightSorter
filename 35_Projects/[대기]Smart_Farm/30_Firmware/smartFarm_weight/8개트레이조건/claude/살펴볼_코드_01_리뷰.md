# 전자저울 코드 리뷰 - 포도 무게 조합 최적화 알고리즘

## 개요
이 코드는 포도 송이들을 목표 무게(2050g)에 최대한 가깝게 조합하여 패키징하는 알고리즘을 구현했습니다. 주어진 여러 포도 송이의 무게를 최적으로 조합하여 목표 무게와의 차이를 최소화하는 방식으로 작동합니다.

## 코드 구조
1. 상수 정의: `MAX_WEIGHTS`, `MAX_BUNCHES`
2. 전역 변수: 포도 무게 저장 배열, 목표 무게
3. 무게 추가 함수: `addWeight()`
4. 조합 계산 함수: `calculatePackages()`, `findBestCombination()`, `findCombinationRecursive()`
5. 무게 제거 함수: `removeWeight()`

## 장점
1. **재귀적 조합 탐색**: 모든 가능한 조합을 탐색하여 최적의 해답을 찾는 방식 사용
2. **메모리 효율성**: 고정 크기 배열 사용으로 메모리 사용량이 예측 가능함
3. **모듈화**: 기능별로 함수가 잘 분리되어 있음
4. **가독성**: 변수명과 함수명이 기능을 명확히 설명함

## 개선 사항
1. **성능 이슈**: 재귀적 조합 탐색은 데이터가 많아질수록 시간 복잡도가 지수적으로 증가함 (O(2^n))
   - 포도 송이 수가 많아지면 계산 시간이 비현실적으로 길어질 수 있음
   - 동적 프로그래밍 기법을 적용해 중복 계산 제거 고려

2. **예외 처리 부족**:
   - 배열 크기 초과 시 오류 처리가 `addWeight`에만 있고 다른 함수에는 없음
   - 입력값 검증 로직 없음 (음수 무게 등)

3. **하드코딩된 값**:
   - 목표 무게(2050g)가 상수로 하드코딩되어 있어 유연성이 떨어짐
   - 런타임에 설정 가능하게 개선 필요

4. **메모리 사용**:
   - 재귀 호출이 많아지면 스택 오버플로우 위험 존재
   - 특히 아두이노의 제한된 메모리 환경에서 주의 필요

5. **실용성 개선**:
   - 사용자 인터페이스 없음 (입력/출력 방식)
   - 실시간 측정 기능 없음 (실제 저울과 연동 필요)

## 최적화 제안
1. **그리디 알고리즘 적용 고려**:
   - 계산 속도 향상을 위해 완전 탐색 대신 근사 알고리즘 사용 가능
   - 무게가 큰 것부터 조합하는 방식 등

2. **동적 프로그래밍 적용**:
   - 부분 문제의 결과를 저장하여 중복 계산 방지
   - 배낭 문제(Knapsack Problem) 알고리즘 응용

3. **메모리 사용 최적화**:
   - 고정 크기 배열 대신 필요에 따라 메모리를 할당/해제하는 방식 고려

4. **사용자 입력 추가**:
   - 목표 무게를 설정할 수 있는 인터페이스 추가
   - 저울 센서와 연동하여 실시간 무게 측정 기능 구현

## 결론
이 코드는 알고리즘의 기본적인 작동 원리를 잘 구현했으나, 실제 환경에서 사용하기 위해서는 성능 최적화와 사용자 인터페이스 개선이 필요합니다. 특히 아두이노의 제한된 자원에서는 메모리 사용과 계산 효율성을 더욱 고려해야 할 것입니다.