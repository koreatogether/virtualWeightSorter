HX711_MP 라이브러리를 사용하여 캘리브레이션하는 방법은 다음과 같습니다:  
원시 데이터 측정: 먼저, 다양한 무게에 대한 원시 데이터를 측정합니다.  
이때, 0 무게(즉, 아무것도 올리지 않은 상태)도 포함해야 합니다.  
캘리브레이션 포인트 설정: setCalibrate(index, raw, weight) 함수를 사용하여 각 원시 데이터와 실제 무게를 매핑합니다.  
여기서 index는 0부터 시작하는 인덱스입니다.  
예를 들어, 10개의 캘리브레이션 포인트가 있다면, 인덱스는 0부터 9까지입니다.  
인덱스는 증가하는 원시 값 순서로 설정해야 합니다.  
캘리브레이션 값 하드코딩: 일반적으로, 찾은 캘리브레이션 값을 Arduino 프로그램의 setup() 함수에 하드코딩합니다.  
이렇게 하면 장치가 시작될 때마다 캘리브레이션이 적용됩니다.  
캘리브레이션 조정 (선택 사항): 필요에 따라 adjustCalibrateRaw(index, amount) 함수를 사용하여 런타임 동안 캘리브레이션을 조정할 수 있습니다.  
이는 프로그램을 다시 컴파일하지 않고도 캘리브레이션을 미세 조정하는 데 유용합니다.  
캘리브레이션 크기 확인: getCalibrateSize()를 사용하여 설정한 캘리브레이션 배열의 크기를 확인합니다.  
이는 사용하려는 캘리브레이션 포인트의 수와 일치해야 합니다.  
캘리브레이션 데이터 검색: getCalibrateRaw(index)와 getCalibrateWeight(index)를 사용하여 특정 캘리브레이션 포인트에 대한 원시 값이나 매핑된 무게를 검색할 수 있습니다.  
이 단계를 따라 HX711_MP 라이브러리의 멀티포인트 캘리브레이션 기능을 사용하여 비선형 센서 읽기를 보정할 수 있습니다.  



`HX711_MP::_multiMap` 함수의 목적은 주어진 원시 센서 값(`val`)을 캘리브레이션 포인트를 사용하여 대응되는 무게로 매핑하는 것입니다. 이 함수는 선형 보간법을 사용하여 캘리브레이션 포인트 사이의 값을 부드럽게 변환합니다. 다음은 함수의 작동 방식에 대한 설명입니다:

1. **경계 확인**: 함수는 먼저 입력 값 `val`이 캘리브레이션 포인트의 범위를 벗어나는지 확인합니다. `val`이 가장 작은 캘리브레이션 입력(`_in`)보다 작거나 같으면 가장 작은 캘리브레이션 출력(`_out`)을 반환합니다. 반대로, `val`이 가장 큰 캘리브레이션 입력(`_in[_size-1]`)보다 크거나 같으면 가장 큰 캘리브레이션 출력(`_out[_size-1]`)을 반환합니다.

2. **구간 검색**: `val`이 범위 내에 있는 경우, 함수는 `val`이 두 캘리브레이션 포인트 사이에 위치하는 구간을 찾기 위해 `pos`를 증가시킵니다.

3. **정확한 일치**: `val`이 캘리브레이션 입력 중 하나와 정확히 일치하는 경우, 해당 캘리브레이션 출력 값을 직접 반환합니다.

4. **보간**: 두 캘리브레이션 포인트 사이에 위치하는 값에 대해서는 선형 보간법을 사용하여 출력을 계산합니다. 이는 `val`이 두 캘리브레이션 입력 사이에서 차지하는 상대적인 위치를 계산하고, 이를 사용하여 대응되는 캘리브레이션 출력 간의 차이를 적용합니다.

이 함수는 원시 센서 값과 실제 무게 간의 매핑을 정확하고 부드럽게 만들어, 비선형적인 센서 특성을 효과적으로 보정할 수 있도록 합니다.

Citations:
[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/13193813/ebcfe80f-58a9-45d8-9dae-2e1e7bc74282/paste.txt