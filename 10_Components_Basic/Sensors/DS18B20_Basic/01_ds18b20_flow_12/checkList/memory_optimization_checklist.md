# 메모리 최적화 체크리스트

## 현재 상황 요약
- **보드**: Arduino UNO R4 WiFi (Renesas)
- **현재 RAM 사용량**: 16,592 bytes / 32,768 bytes = **50.6%**
- **Flash 사용량**: 71,512 bytes / 262,144 bytes = **27.3%**
- **상태**: ⚠️ RAM 사용량이 중간 수준으로 최적화 필요

## 즉시 조치가 필요한 항목

### 1. 큰 배열 및 데이터 구조 최적화 ⚠️ 데이터 손실 위험
- [ ] ⚠️ 전역 배열 크기 검토 및 축소 (데이터 오버플로우 위험)
- [ ] ⚠️ 임시 버퍼 크기 최적화 (통신 오류 가능성)
- [ ] ✅ 사용하지 않는 배열 제거 (안전한 최적화)
- [ ] ⚠️ 다차원 배열을 1차원으로 변경 고려 (인덱싱 로직 변경 필요)

### 2. String 객체 사용량 감소 ⚠️ 기능 영향 가능성
- [ ] ⚠️ `String` 객체를 `char[]` 배열로 교체 (문자열 처리 로직 변경 필요)
- [ ] ✅ 문자열 연결 작업 최소화 (안전한 최적화)
- [ ] ✅ 임시 String 객체 생성 줄이기 (안전한 최적화)
- [x] ✅ F() 매크로 사용하여 문자열을 Flash에 저장 (안전한 최적화) - **완료: 일부 적용**

### 3. 라이브러리 및 의존성 최적화 ⚠️ 호환성 검토 필요
- [ ] ⚠️ 사용하지 않는 라이브러리 제거 (컴파일 오류 가능성)
- [ ] ⚠️ 더 가벼운 대안 라이브러리 검토 (기능 변경 위험)
- [ ] ✅ OneWire 및 DallasTemperature 라이브러리 사용량 최적화 (안전한 최적화)
- [ ] ✅ 불필요한 기능 비활성화 (안전한 최적화)

### 4. 전역 변수 최적화
- [ ] ⚠️ 전역 변수를 지역 변수로 변경 가능한지 검토 (스코프 변경 영향)
- [ ] ✅ 구조체 멤버 순서 최적화 (패딩 최소화) - 안전한 최적화
- [ ] ⚠️ 불필요한 전역 객체 제거 (다른 모듈에서 참조 가능성)
- [x] ✅ 상수를 PROGMEM으로 이동 (안전한 최적화) - **완료: 효과 제한적**

## 권장 조치사항

### 5. 메모리 효율적 코딩 패턴
- [ ] ✅ 함수 지역 변수 크기 줄이기 (안전한 최적화)
- [ ] ⚠️ 깊은 함수 호출 스택 피하기 (코드 구조 변경 필요)
- [ ] ⚠️ 재귀 함수 사용 최소화 (알고리즘 변경 필요)
- [ ] ✅ 동적 메모리 할당(`malloc`, `new`) 피하기 (안전한 최적화)

### 6. 데이터 타입 최적화
- [ ] ⚠️ `int` 대신 `byte` 또는 `uint8_t` 사용 가능한지 검토 (값 범위 확인 필요)
- [ ] ⚠️ `float` 대신 정수 연산 고려 (정밀도 손실 가능성)
- [ ] ⚠️ 불필요하게 큰 데이터 타입 축소 (오버플로우 위험)
- [ ] ✅ 비트 필드 또는 플래그 사용 검토 (안전한 최적화)

### 7. 코드 구조 개선
- [ ] ✅ 중복 코드 제거 및 함수화 (안전한 최적화)
- [ ] ✅ 불필요한 기능 비활성화 옵션 추가 (안전한 최적화)
- [ ] ✅ 조건부 컴파일(`#ifdef`) 활용 (안전한 최적화)
- [ ] ✅ 디버그 코드 제거 또는 조건부 컴파일 (안전한 최적화)

## 모니터링 및 측정

### 8. 메모리 사용량 추적
- [ ] ✅ 정기적인 메모리 사용량 측정 (안전한 모니터링)
- [ ] ✅ 기능별 메모리 사용량 프로파일링 (안전한 분석)
- [ ] ⚠️ 런타임 메모리 사용량 모니터링 (가능한 경우) - 추가 메모리 필요
- [ ] ⚠️ 스택 오버플로우 감지 코드 추가 (추가 메모리 필요)

### 9. 테스트 및 검증
- [ ] 메모리 최적화 후 기능 테스트
- [ ] 장시간 동작 안정성 테스트
- [ ] 극한 상황에서의 메모리 부족 테스트
- [ ] 메모리 누수 검사

## 메모리 안정성 중심 전략 🛡️

### 현재 상황 재평가
- **RAM 사용량**: 16,592 bytes / 32,768 bytes = **50.6%** (Renesas UNO R4 WiFi)
- **Flash 사용량**: 71,912 bytes / 262,144 bytes = **27.4%** (여유로움)
- **평가**: 추가 최적화보다는 **안정성 확보**가 우선

### 🎯 새로운 목표: 메모리 안정성
- **목표 1**: 메모리 오버플로우 방지
- **목표 2**: 스택/힙 충돌 방지
- **목표 3**: 런타임 안정성 확보
- **목표 4**: 메모리 누수 방지

## 메모리 안정성 체크리스트

### 1. 메모리 경계 보호 🚧
- [v] 배열 경계 검사 추가 (buffer overflow 방지)
- [v] 문자열 복사 시 크기 제한 (strcpy → strncpy)
- [v] snprintf 사용으로 버퍼 오버런 방지
- [v] 동적 할당 전 null 체크

### 2. 스택 오버플로우 방지 📚
- [v] 큰 지역 변수를 static 또는 전역으로 이동
- [v] 깊은 재귀 호출 제한
- [v] 함수 호출 깊이 모니터링
- [v] 스택 사용량 추적 코드 추가

### 3. 메모리 누수 방지 💧
- [v] malloc/free 쌍 매칭 검증
- [v] new/delete 쌍 매칭 검증
- [v] String 객체 라이프사이클 관리
- [v] 메모리 할당 실패 처리

### 4. 런타임 안정성 ⚡
- [v] 메모리 사용량 실시간 모니터링
- [v] 임계 상황 감지 및 대응
- [v] 안전한 리셋/복구 메커니즘
- [v] 메모리 부족 시 graceful degradation

### 5. 코드 안정성 패턴 🔧
- [v] 방어적 프로그래밍 패턴 적용
- [v] 입력 검증 강화
- [v] 에러 처리 개선
- [v] 안전한 포인터 사용법

## 우선순위 안정성 작업

### 🚨 즉시 적용 (High Priority) ✅ **완료됨**
1. **✅ 배열 경계 검사** - buffer overflow는 시스템 크래시 직결
2. **✅ snprintf 사용** - 문자열 처리 시 버퍼 오버런 방지
3. **✅ 포인터 null 체크** - segmentation fault 방지
4. **✅ 메모리 할당 실패 처리** - malloc/new 실패 시 대응
5. **✅ F() 매크로 지원** - 함수 오버로드로 완전 지원

### ⚠️ 단기 적용 (Medium Priority) 🔄 **진행중**
1. **🔄 메모리 사용량 모니터링** - 런타임 추적 (기본형 완료)
2. **📋 스택 깊이 제한** - 재귀/호출 스택 관리
3. **📋 String 객체 관리** - 라이프사이클 최적화
4. **📋 에러 복구 메커니즘** - 안정적 시스템 운영

### 📊 장기 적용 (Low Priority) 📋 **계획중**
1. **📋 메모리 프로파일링** - 상세 분석 도구
2. **📋 자동 테스트** - 메모리 관련 유닛 테스트
3. **📋 문서화** - 메모리 사용 가이드라인
4. **📋 모니터링 시스템** - 지속적 관찰

## 📈 최신 성과 (2025-07-28)

### ✅ 핵심 안전성 기능 완료
- **버퍼 오버플로우 방지**: Utils.cpp의 sprintf → snprintf 교체
- **메모리 할당 안전성**: MemoryUsageTester의 null 체크 구현
- **함수 오버로드**: log_error/info/debug F() 매크로 지원
- **컴파일 안정성**: 타입 안전성 완전 확보

### 📊 메모리 상태 (안전성 강화 후)
- **Flash**: 72,868 bytes / 262,144 bytes (27.8%) [+376 bytes]
- **RAM**: 16,592 bytes / 32,768 bytes (50.6%) [변화없음]
- **안전성 투자**: 376 bytes로 견고한 시스템 구축

## 주의사항

### ⚠️ 최적화 시 주의할 점
- [ ] ⚠️ 기능 손실 없이 최적화 진행 (철저한 테스트 필요)
- [ ] ⚠️ 코드 가독성 유지 (유지보수성 고려)
- [ ] ⚠️ 성능 저하 없이 메모리 절약 (벤치마크 테스트 필요)
- [ ] ⚠️ 충분한 테스트 후 적용 (단계별 검증 필수)

### 🔍 우선순위 검토 항목 (안전한 조치부터 시작)
1. **✅ F() 매크로 적용** - 문자열을 Flash 메모리로 이동 (가장 안전)
2. **✅ 디버그 코드 정리** - 불필요한 Serial.print 제거 (안전)
3. **⚠️ DS18B20 센서 관련 코드** - 센서 수 및 데이터 저장 방식 (기능 검토 필요)
4. **⚠️ App.cpp의 대용량 코드** - 40KB 이상의 큰 파일 (구조 변경 필요)
5. **⚠️ 통신 버퍼** - Communicator 클래스의 버퍼 크기 (통신 안정성 고려)
6. **⚠️ 데이터 처리** - DataProcessor의 임시 변수들 (처리 로직 변경 필요)

## 진행 상황 기록

| 날짜       | 작업 내용 | RAM 사용량           | 변화량 | 비고   |
| ---------- | --------- | -------------------- | ------ | ------ |
| 2025-07-28 | 초기 측정 | 16,592 bytes (50.6%) | -      | 기준점 |
|            |           |                      |        |        |
|            |           |                      |        |        |

---


**마지막 업데이트**: 2025-07-28
**목표 달성도**: 0% (시작 단계)
**다음 검토일**: 2025-08-04
