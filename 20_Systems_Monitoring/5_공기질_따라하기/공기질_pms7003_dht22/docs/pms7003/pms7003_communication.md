**PMS7003**은 Plantower사에서 만든 매우 대중적인 레이저 미세먼지 센서입니다. 이 센서는 **UART(시리얼) 통신** 방식을 사용하여 마이크로컨트롤러(Arduino, Raspberry Pi, STM32 등)와 데이터를 주고받습니다.

PMS7003의 통신 방법과 데이터 구조를 단계별로 정리해 드립니다.

---

### 1. 하드웨어 연결 및 통신 규격

이 센서는 **TTL Level(3.3V) UART 통신**을 합니다.

#### 1.1 핀 연결 (기본)
센서에는 8개 또는 10개의 핀이 있지만, 데이터 수신을 위해서는 주로 **4개**만 연결하면 됩니다.

*   **VCC (Pin 1):** 5V DC 전원 (주의: 센서 구동은 5V가 필요)
*   **GND (Pin 2):** 그라운드
*   **TX (Pin 5):** 센서의 데이터 송신 핀 (MCU의 RX에 연결)
*   **RX (Pin 4):** 센서의 데이터 수신 핀 (MCU의 TX에 연결, 명령을 보낼 때만 필요)

**⚠️ 주의사항 (로직 레벨):**
센서의 내부 로직과 통신 전압은 **3.3V**입니다.
*   **Arduino Uno(5V) 사용 시:** 센서의 TX -> 아두이노 RX는 바로 연결해도 보통 작동하지만, 아두이노 TX -> 센서 RX로 명령을 보낼 때는 **레벨 시프터**나 저항 분배를 사용하여 5V를 3.3V로 낮춰주는 것이 안전합니다.
*   **Raspberry Pi / ESP32 (3.3V) 사용 시:** 바로 직결(Direct)하면 됩니다.

#### 1.2 통신 설정 (Baud Rate)
*   **속도 (Baud Rate):** 9600 bps
*   **데이터 비트:** 8 bits
*   **패리티 (Parity):** None
*   **스톱 비트 (Stop Bit):** 1 bit
*   **흐름 제어:** None

---

### 2. 데이터 패킷 구조 (프로토콜)

PMS7003은 기본적으로 **Active Mode**로 동작하여, 전원이 켜지면 약 200~1000ms 간격으로 **32바이트(Byte)** 길이의 데이터를 계속해서 보냅니다.

데이터는 16진수(Hex) 형태로 들어오며 구조는 다음과 같습니다.

| 바이트 순서    | 설명                  | 내용 (Hex)     | 비고                                    |
| :------------- | :-------------------- | :------------- | :-------------------------------------- |
| **Byte 0**     | 헤더 1                | `0x42`         | 고정값 (B)                              |
| **Byte 1**     | 헤더 2                | `0x4D`         | 고정값 (M)                              |
| **Byte 2~3**   | 프레임 길이           | `0x00`, `0x1C` | 전체 프레임 길이 (보통 28 bytes = 0x1C) |
| **Byte 4~5**   | **PM1.0 (CF=1)**      | Data           | 표준 입자 (공장/실험실용 보정값)        |
| **Byte 6~7**   | **PM2.5 (CF=1)**      | Data           | "                                       |
| **Byte 8~9**   | **PM10 (CF=1)**       | Data           | "                                       |
| **Byte 10~11** | **PM1.0 (대기)**      | Data           | **실생활 대기 환경용 (우리가 쓸 값)**   |
| **Byte 12~13** | **PM2.5 (대기)**      | Data           | **"**                                   |
| **Byte 14~15** | **PM10 (대기)**       | Data           | **"**                                   |
| **Byte 16~27** | 입자 개수 데이터      | Data           | 0.3um 이상, 0.5um 이상 등 입자 개수     |
| **Byte 28**    | 버전 정보             | Data           |                                         |
| **Byte 29**    | 에러 코드             | Data           |                                         |
| **Byte 30~31** | **체크섬 (Checksum)** | Data           | 데이터 유효성 검사                      |

---

### 3. 데이터 해석 방법 (프로그래밍 로직)

데이터를 읽어서 실제 미세먼지 농도(㎍/㎥)로 변환하는 과정은 다음과 같습니다.

#### 1단계: 헤더 찾기
시리얼 버퍼에서 들어오는 데이터 중 연속으로 `0x42`, `0x4D`가 들어오는 지점을 찾습니다. 이것이 패킷의 시작입니다.

#### 2단계: 데이터 수집
헤더를 포함하여 총 **32바이트**를 읽어옵니다.

#### 3단계: 값 계산 (Big Endian)
각 데이터는 2바이트(16비트)로 구성되어 있으며, **상위 바이트(High Byte)**가 먼저 오고 **하위 바이트(Low Byte)**가 뒤에 옵니다.

예를 들어 **PM2.5 (대기 환경)** 값을 구하고 싶다면 12번째와 13번째 바이트를 사용합니다.
> **PM2.5 값 = (Byte[12] * 256) + Byte[13]**

> **💡 왜 256을 곱하나요?**
> 상위 바이트(High Byte)는 16비트 데이터에서 앞쪽 8비트를 담당합니다.
> 2진수에서 8칸 왼쪽으로 이동(Shift)하는 것은 $2^8$, 즉 **256**을 곱하는 것과 같습니다.
> (`High Byte << 8` == `High Byte * 256`)

#### 4단계: 체크섬 검사 (데이터 무결성 확인)
통신 노이즈로 인해 값이 깨졌는지 확인해야 합니다.
*   **계산법:** Byte 0부터 Byte 29까지 모든 값을 더합니다.
*   **검증:** 더한 결과가 Byte 30(High)과 Byte 31(Low)을 합친 값과 같은지 비교합니다. 같다면 정상 데이터입니다.

---

### 4. 요약: 실제로 사용하는 데이터

일반적인 공기청정기나 모니터링 용도로는 **"대기 환경 하에서의 농도 (Concentration Unit under atmospheric environment)"** 값을 사용합니다.

*   **PM 1.0:** Byte 10, 11
*   **PM 2.5:** Byte 12, 13 (**가장 중요**)
*   **PM 10:** Byte 14, 15

### 5. 팁 (명령어 모드)

기본적으로 센서는 데이터를 막 뱉어내지만(Active Mode), 필요한 경우에만 요청해서 데이터를 받는 **Passive Mode**로 바꿀 수도 있습니다.

*   **Passive Mode 전환 명령 (Hex):**
    `42 4D E1 00 00 01 70`
*   **데이터 요청 명령 (Read):**
    `42 4D E2 00 00 01 71`

이 모드는 센서의 팬 수명을 늘리거나, 데이터 처리 타이밍을 정확히 맞출 때 유용합니다.

### 6. 슬립 모드 (Sleep Mode)

센서를 장시간 사용하지 않을 때는 **Sleep Mode**로 전환하여 팬과 레이저를 끄고 수명을 연장할 수 있습니다.

**⚠️ 주의: Active Mode에서 바로 Sleep 명령을 보내면 명령이 무시될 수 있습니다!**
Active Mode에서는 센서가 데이터를 계속 보내느라 바빠서 Sleep 명령을 제대로 인식하지 못하는 경우가 많습니다. 따라서 **Passive Mode로 먼저 변경하여 데이터 전송을 멈춘 후** Sleep 명령을 보내는 것이 가장 확실한 방법입니다.

**[권장 슬립 진입 순서]**
1.  **Passive Mode 전환:** `42 4D E1 00 00 01 70` (데이터 스트림 중단)
2.  **약간 대기:** (약 100ms ~ 500ms)
3.  **Sleep 진입:** `42 4D E4 00 00 01 73`

---

*   **Wake Up (깨우기):** `42 4D E4 00 01 01 74`
    *   깨어난 직후에는 Passive Mode 상태가 유지될 수 있으므로, 필요하다면 다시 Active Mode로 변경(`42 4D E1 00 01 01 71`)하거나 Passive 상태에서 Read 명령을 사용하세요.

> **참고:** Wake Up 명령을 보낸 후, 공기 흐름이 안정되고 데이터가 정확해질 때까지 **최소 30초** 정도 대기하는 것이 좋습니다.

### 7. 개발 예시 (Python 의사 코드)

```python
# 시리얼 포트에서 1바이트씩 읽음
if serial.read() == b'\x42':
    if serial.read() == b'\x4d':
        # 나머지 30바이트를 읽음
        data = serial.read(30)
        
        # PM2.5 (대기환경) 값 추출 (인덱스는 헤더 2바이트 제외 후 계산)
        # 원래 표의 Byte 12, 13은 여기서 인덱스 10, 11이 됨
        pm25_high = data[10]
        pm25_low = data[11]
        
        pm25_value = (pm25_high << 8) | pm25_low
        print(f"PM2.5 농도: {pm25_value} ug/m3")
```

