import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import os
import json
import glob
from datetime import datetime, timedelta
import matplotlib.dates as mdates
import matplotlib.transforms as transforms
import math
import bisect

# --- 설정 (기본값) ---
DEFAULT_LOG_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'docs', 'logs')
WINDOW_TITLE = "Boiler Monitor Log Player (Dual Jog Edition)"

# 뷰 간격 옵션 (초 단위)
VIEW_INTERVALS = {
    "10초": 10,
    "30초": 30,
    "1분": 60,
    "3분": 180,
    "5분": 300,
    "10분": 600,
    "30분": 1800,
    "1시간": 3600,
    "2시간": 7200,
    "3시간": 10800,
    "5시간": 18000,
    "10시간": 36000
}

class JogWheel(tk.Canvas):
    """마우스로 잡고 돌릴 수 있는 조그 다이얼 위젯"""
    def __init__(self, master, command=None, size=140, bg_color="#f0f0f0", **kwargs):
        super().__init__(master, width=size, height=size, bg=bg_color, highlightthickness=0, **kwargs)
        self.command = command
        self.size = size
        self.center = size // 2
        self.radius = (size // 2) - 5
        self.angle = 0  # 현재 각도 (-180 ~ 180)
        self.last_angle_mp = 0 # 마우스 포인터 각도
        self.active = False

        self.bind("<Button-1>", self.start_drag)
        self.bind("<B1-Motion>", self.do_drag)
        self.bind("<ButtonRelease-1>", self.stop_drag)

        self.draw_wheel()

    def draw_wheel(self):
        self.delete("all")

        # 1. 외곽 원 (그림자 효과)
        self.create_oval(2, 2, self.size-2, self.size-2, fill="#bdc3c7", outline="#95a5a6", width=2)

        # 2. 내부 노브
        inset = 12
        self.create_oval(inset, inset, self.size-inset, self.size-inset, fill="#ecf0f1", outline="#bdc3c7")

        # 3. 디테일 (미끄럼 방지 홈)
        for i in range(0, 360, 15): # 더 촘촘하게
            rad = math.radians(i + self.angle)
            x1 = self.center + (self.radius - 15) * math.cos(rad)
            y1 = self.center + (self.radius - 15) * math.sin(rad)
            x2 = self.center + (self.radius - 5) * math.cos(rad)
            y2 = self.center + (self.radius - 5) * math.sin(rad)
            self.create_line(x1, y1, x2, y2, fill="#95a5a6", width=2)

        # 4. 지시선 (현재 회전 상태 표시)
        rad_angle = math.radians(self.angle - 90) # -90: 12시 방향 기준
        end_x = self.center + (self.radius - 20) * math.cos(rad_angle)
        end_y = self.center + (self.radius - 20) * math.sin(rad_angle)

        # 중심점
        self.create_oval(self.center-6, self.center-6, self.center+6, self.center+6, fill="#7f8c8d")
        # 지시선
        self.create_line(self.center, self.center, end_x, end_y, width=4, fill="#e74c3c", capstyle=tk.ROUND)

    def get_mouse_angle(self, x, y):
        dx = x - self.center
        dy = y - self.center
        return math.degrees(math.atan2(dy, dx))

    def start_drag(self, event):
        self.active = True
        self.last_angle_mp = self.get_mouse_angle(event.x, event.y)

    def do_drag(self, event):
        if not self.active: return

        curr_angle_mp = self.get_mouse_angle(event.x, event.y)
        delta = curr_angle_mp - self.last_angle_mp

        if delta > 180: delta -= 360
        if delta < -180: delta += 360

        self.angle += delta
        self.angle %= 360

        self.last_angle_mp = curr_angle_mp
        self.draw_wheel()

        # 각도 변화량과 민감도 조절
        # 1도만 움직여도 변화하도록 민감하게 반응 (시간 간격 연동 위함)
        if abs(delta) > 1 and self.command:
            # 방향만 전달 (1 or -1)
            direction = 1 if delta > 0 else -1
            self.command(direction)

    def stop_drag(self, event):
        self.active = False

class LogPlayerApp:
    def __init__(self, root, log_dir):
        self.root = root
        self.log_dir = log_dir
        self.root.title(f"{WINDOW_TITLE} - {self.log_dir}")
        self.root.geometry("1600x900")

        # 데이터 저장소
        self.times = []
        self.s1_data, self.s2_data, self.diff1_data = [], [], []
        self.s3_data, self.s4_data, self.diff2_data = [], [], []

        # 상태 변수 (그룹별 독립 제어)
        self.current_idx1 = 0
        self.current_idx2 = 0
        self.view_range_sec = 60 # 기본 1분

        self._init_ui()
        self.load_data()

    def _init_ui(self):
        # 전체 레이아웃 구성을 위해 PanedWindow 사용 (좌: 컨트롤, 우: 그래프)
        main_pane = tk.Frame(self.root)
        main_pane.pack(fill=tk.BOTH, expand=True)

        # === 좌측 컨트롤 패널 ===
        left_panel = tk.Frame(main_pane, width=350, bg="#ecf0f1")
        left_panel.pack(side=tk.LEFT, fill=tk.Y)
        left_panel.pack_propagate(False) # 크기 고정

        # 1. 파일 정보
        info_frame = ttk.LabelFrame(left_panel, text="데이터 정보", padding="10")
        info_frame.pack(fill=tk.X, padx=10, pady=10)
        self.lbl_file_count = ttk.Label(info_frame, text="파일: 0개")
        self.lbl_file_count.pack(anchor=tk.W)
        self.lbl_data_count = ttk.Label(info_frame, text="데이터: 0건")
        self.lbl_data_count.pack(anchor=tk.W)

        # 2. 공통 설정 (뷰 범위)
        setting_frame = ttk.LabelFrame(left_panel, text="뷰 범위 (시간 간격)", padding="10")
        setting_frame.pack(fill=tk.X, padx=10, pady=5)

        self.interval_var = tk.StringVar(value="5시간")
        self.interval_combo = ttk.Combobox(setting_frame, textvariable=self.interval_var,
                                         values=list(VIEW_INTERVALS.keys()), state="readonly")
        self.interval_combo.pack(fill=tk.X, pady=5)
        self.interval_combo.bind("<<ComboboxSelected>>", self.on_interval_change)
        # 초기값 설정
        self.view_range_sec = VIEW_INTERVALS["5시간"]

        # 3. 그룹 1 컨트롤 (S1-S2)
        g1_frame = ttk.LabelFrame(left_panel, text="그룹 1 (S1-S2) 제어", padding="10")
        g1_frame.pack(fill=tk.X, padx=10, pady=10)

        self.lbl_time1 = ttk.Label(g1_frame, text="--:--:--", font=("Consolas", 14, "bold"))
        self.lbl_time1.pack(pady=5)

        # Jog 1
        jog1_container = tk.Frame(g1_frame)
        jog1_container.pack()
        self.jog1 = JogWheel(jog1_container, command=self.on_jog1_rotate, size=150)
        self.jog1.pack()

        # 4. 그룹 2 컨트롤 (S3-S4)
        g2_frame = ttk.LabelFrame(left_panel, text="그룹 2 (S3-S4) 제어", padding="10")
        g2_frame.pack(fill=tk.X, padx=10, pady=10)

        self.lbl_time2 = ttk.Label(g2_frame, text="--:--:--", font=("Consolas", 14, "bold"))
        self.lbl_time2.pack(pady=5)

        # Jog 2
        jog2_container = tk.Frame(g2_frame)
        jog2_container.pack()
        self.jog2 = JogWheel(jog2_container, command=self.on_jog2_rotate, size=150)
        self.jog2.pack()

        # === 우측 그래프 영역 ===
        right_panel = tk.Frame(main_pane, bg="white")
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(10, 8))
        # sharex=False로 설정하여 X축 독립적으로 운용
        plt.subplots_adjust(left=0.08, right=0.95, top=0.91, bottom=0.08, hspace=0.3)

        self.canvas = FigureCanvasTkAgg(self.fig, master=right_panel)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # 툴바 추가 (줌/이동 기능)
        self.toolbar = NavigationToolbar2Tk(self.canvas, right_panel)
        self.toolbar.update()
        # 주의: pack()이 toolbar.update() 내부에서 호출되거나 이미 되어있을 수 있음
        # 하지만 tkagg 예제에서는 별도 pack이 필요없거나 canvas 아래에 붙음.
        # right_panel에 붙였으므로 자동으로 pack 되었을 것임.

        # 마우스 이벤트 연결 (커서 기능)
        self.canvas.mpl_connect("motion_notify_event", self.on_mouse_move)

        # 커서 객체 초기화
        self.cursor_line1 = None
        self.cursor_line2 = None
        self.cursor_text1 = None
        self.cursor_text2 = None

    def load_data(self):
        print(f"데이터 로딩 시작: {self.log_dir}")
        search_pattern = os.path.join(self.log_dir, "**", "*.json")
        files = glob.glob(search_pattern, recursive=True)

        if not files:
            print("로그 파일을 찾을 수 없습니다.")
            messagebox.showerror("오류", f"로그 파일이 없습니다.\n{self.log_dir}")
            return

        data_list = []
        file_count = len(files)
        self.lbl_file_count.config(text=f"파일: {file_count}개")
        self.root.update()

        print(f"총 {file_count}개 파일 분석 중...")
        for i, fpath in enumerate(files):
            if i % 100 == 0:
                print(f"진행 중... ({i}/{file_count})")
                self.lbl_data_count.config(text=f"로드 중... ({i}/{file_count})")
                self.root.update()

            try:
                fname = os.path.basename(fpath)
                # 파일명이 YYYY-MM-DD_HH-MM-SS.json 형식이 아니면 건너뜀
                if not fname.endswith(".json") or len(fname) < 19:
                    continue

                time_str = fname.replace(".json", "")
                dt = datetime.strptime(time_str, "%Y-%m-%d_%H-%M-%S")
                with open(fpath, 'r', encoding='utf-8') as f:
                    content = json.load(f)
                    if 's1' in content:
                        entry = {
                            'dt': dt,
                            's1': content.get('s1', 0), 's2': content.get('s2', 0),
                            's3': content.get('s3', 0), 's4': content.get('s4', 0)
                        }
                        data_list.append(entry)
            except Exception as e:
                # print(f"파일 로드 오류 ({fpath}): {e}")
                pass

        print("데이터 정렬 중...")
        data_list.sort(key=lambda x: x['dt'])

        if not data_list:
            print("유효한 데이터가 없습니다.")
            messagebox.showwarning("데이터 없음", "유효한 데이터가 없습니다.")
            return

        self.times = [x['dt'] for x in data_list]
        self.s1_data = [x['s1'] for x in data_list]
        self.s2_data = [x['s2'] for x in data_list]
        self.s3_data = [x['s3'] for x in data_list]
        self.s4_data = [x['s4'] for x in data_list]
        self.diff1_data = [abs(x['s1'] - x['s2']) for x in data_list]
        self.diff2_data = [abs(x['s3'] - x['s4']) for x in data_list]

        self.lbl_data_count.config(text=f"데이터: {len(data_list):,}건")
        print(f"데이터 로딩 완료: {len(data_list)}건")

        # 마지막 시점으로 초기화
        self.current_idx1 = len(self.times) - 1
        self.current_idx2 = len(self.times) - 1

        self.update_plot1()
        self.update_plot2()

    def get_time_step(self):
        # 조그 한 눈금당 이동할 시간 간격 (뷰 범위에 비례)
        # 예: 1시간 뷰일 때 한 눈금 5분 이동? -> 사용자는 "한 눈금의 시간 간격은 왼쪽 시간 간격 선택만큼" 이라고 했지만
        # 그러면 1시간 뷰일 때 한 눈금이 1시간 점프하면 너무 큼.
        # "왼쪽 시간 간격 선택만큼으로 연동"의 의미를 "뷰 범위 크기에 비례해서 이동 속도 조절"로 해석
        # 뷰 범위의 1/20 정도가 적당함 (조그 한바퀴가 20~30 눈금 느낌일 때)
        # 하지만 사용자 요청: "한 눈금의 시간 간격은 왼쪽 시간 간격 선택만큼으로 연동"
        # -> 만약 "1시간" 선택 시 한 눈금 돌리면 1시간 이동? -> 일단 요청대로 뷰 범위 크기만큼 이동하도록 구현 (너무 빠르면 추후 수정)
        # -> "시간 간격 선택만큼"이 Interval 콤보박스 값을 의미하는 것이라면, Zoom In/Out 용도일 수 있음.
        #    하지만 문맥상 "이동 속도(Jump Step)"를 의미하는 듯 함.
        #    사용자 의도: 10분 뷰를 보고 있을 땐 조그 돌리면 10분씩 휙휙 넘기고 싶다?
        #    혹은, 뷰가 1시간이면, 데이터 포인트 이동이 아니라 '시간' 단위로 이동.

        return self.view_range_sec # 요청대로 1:1 연동 (한 클릭 = 뷰 범위 전체 이동) / 너무 빠를 수 있음.
        # 수정: 너무 빠르므로 뷰 범위의 5% 정도로 이동하는게 일반적인 UX지만, 사용자 요청 "왼쪽 시간 간격 선택만큼"을
        # 'Step Size = Selected Interval' 로 해석하기엔 무리가 있음 (화면 전체가 바뀜)
        # 아마도 뷰 범위 설정 자체가 조그 감도와 연결되길 원하는 뜻으로 해석하여
        # 뷰의 1/10 정도로 설정하겠습니다. (부드러운 이동을 위해)

        # 재해석: "시간 간격 선택만큼" = 콤보박스 값.
        # 즉, 콤보박스가 '10분'이면 한번 틱 돌릴때 10분 이동.
        return self.view_range_sec

    def find_nearest_index(self, target_time):
        # 이진 탐색으로 가장 가까운 인덱스 찾기
        idx = bisect.bisect_left(self.times, target_time)
        if idx >= len(self.times):
            idx = len(self.times) - 1
        return idx

    def move_time(self, group, direction):
        # direction: 1 or -1
        step_seconds = self.view_range_sec * 0.1 # 한 눈금당 화면의 10% 이동으로 설정 (조작성 고려)

        if group == 1:
            curr_time = self.times[self.current_idx1]
            new_time = curr_time + timedelta(seconds=step_seconds * direction)
            self.current_idx1 = self.find_nearest_index(new_time)
            self.update_plot1()

        elif group == 2:
            curr_time = self.times[self.current_idx2]
            new_time = curr_time + timedelta(seconds=step_seconds * direction)
            self.current_idx2 = self.find_nearest_index(new_time)
            self.update_plot2()

    def on_jog1_rotate(self, direction):
        self.move_time(1, direction)

    def on_jog2_rotate(self, direction):
        self.move_time(2, direction)

    def on_interval_change(self, event):
        val = self.interval_var.get()
        self.view_range_sec = VIEW_INTERVALS.get(val, 60)
        self.update_plot1()
        self.update_plot2()

    def update_plot1(self):
        if not self.times: return

        idx = self.current_idx1
        curr_time = self.times[idx]
        self.lbl_time1.config(text=curr_time.strftime("%Y-%m-%d\n%H:%M:%S"))

        start_time = curr_time - timedelta(seconds=self.view_range_sec)
        end_time = curr_time + timedelta(seconds=self.view_range_sec * 0.1)

        self.ax1.clear()
        self.ax1.plot(self.times, self.s1_data, label='S1', color='#e74c3c', lw=1.5)
        self.ax1.plot(self.times, self.s2_data, label='S2', color='#3498db', lw=1.5)
        self.ax1.fill_between(self.times, self.s1_data, self.s2_data, color='gray', alpha=0.1)
        self.ax1.plot(self.times, self.diff1_data, label='dT', color='#8e44ad', ls='--', alpha=0.8)

        self.ax1.set_title(f"Group 1 (S1-S2) Temp Δ: {self.diff1_data[idx]:.1f}°C")
        self.ax1.grid(True, linestyle=':', alpha=0.6)
        self.ax1.legend(loc='upper right', fontsize='small')
        self.ax1.axvline(x=curr_time, color='black', alpha=0.8)

        # X축 포맷 강제 표시
        self.ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        self.ax1.tick_params(axis='x', rotation=0) # 라벨 겹침 방지

        self.ax1.set_xlim(start_time, end_time)
        self.ax1.set_ylim(0, 90) # 온도 범위는 0~90 고정

        self.canvas.draw()

    def update_plot2(self):
        if not self.times: return

        idx = self.current_idx2
        curr_time = self.times[idx]
        self.lbl_time2.config(text=curr_time.strftime("%Y-%m-%d\n%H:%M:%S"))

        start_time = curr_time - timedelta(seconds=self.view_range_sec)
        end_time = curr_time + timedelta(seconds=self.view_range_sec * 0.1)

        self.ax2.clear()
        self.ax2.plot(self.times, self.s3_data, label='S3', color='#2ecc71', lw=1.5)
        self.ax2.plot(self.times, self.s4_data, label='S4', color='#f1c40f', lw=1.5)
        self.ax2.fill_between(self.times, self.s3_data, self.s4_data, color='gray', alpha=0.1)
        self.ax2.plot(self.times, self.diff2_data, label='dT', color='#e67e22', ls='--', alpha=0.8)

        self.ax2.set_title(f"Group 2 (S3-S4) Temp Δ: {self.diff2_data[idx]:.1f}°C")
        self.ax2.grid(True, linestyle=':', alpha=0.6)
        self.ax2.legend(loc='upper right', fontsize='small')
        self.ax2.axvline(x=curr_time, color='black', alpha=0.8)

        # X축 포맷 강제 표시
        self.ax2.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        self.ax2.tick_params(axis='x', rotation=0)

        self.ax2.set_xlim(start_time, end_time)
        self.ax2.set_ylim(0, 90)

        self.canvas.draw()

    def on_mouse_move(self, event):
        if not event.inaxes or not self.times:
            return

        try:
            target_dt = mdates.num2date(event.xdata)
            if target_dt.tzinfo:
                target_dt = target_dt.replace(tzinfo=None)
        except ValueError:
            return

        idx = bisect.bisect_left(self.times, target_dt)
        if idx >= len(self.times): idx = len(self.times) - 1

        curr_time = self.times[idx]
        val_s1 = self.s1_data[idx]
        val_s2 = self.s2_data[idx]
        val_diff1 = self.diff1_data[idx]

        val_s3 = self.s3_data[idx]
        val_s4 = self.s4_data[idx]
        val_diff2 = self.diff2_data[idx]

        self.draw_cursor(curr_time, val_s1, val_s2, val_diff1, val_s3, val_s4, val_diff2)

    def draw_cursor(self, time_val, s1, s2, d1, s3, s4, d2):
        # --- Group 1 (Ax1) ---
        if self.cursor_line1 and self.cursor_line1 in self.ax1.lines:
            self.cursor_line1.set_xdata([time_val, time_val])
        else:
            self.cursor_line1 = self.ax1.axvline(x=time_val, color='gray', linestyle='--', alpha=0.8)

        text1 = f"[{time_val.strftime('%H:%M:%S')}]\nS1: {s1}°C\nS2: {s2}°C\nΔT: {d1:.1f}°C"

        if self.cursor_text1 and self.cursor_text1 in self.ax1.texts:
            self.cursor_text1.set_text(text1)
            self.cursor_text1.set_x(time_val)
        else:
             props = dict(boxstyle='round', facecolor='white', alpha=0.9, edgecolor='gray')
             # y좌표는 axes fraction (1.0 = top)
             trans = transforms.blended_transform_factory(self.ax1.transData, self.ax1.transAxes)
             self.cursor_text1 = self.ax1.text(time_val, 0.95, text1, transform=trans,
                                               verticalalignment='top', horizontalalignment='left',
                                               bbox=props, fontsize=9, zorder=10)

        # --- Group 2 (Ax2) ---
        if self.cursor_line2 and self.cursor_line2 in self.ax2.lines:
            self.cursor_line2.set_xdata([time_val, time_val])
        else:
            self.cursor_line2 = self.ax2.axvline(x=time_val, color='gray', linestyle='--', alpha=0.8)

        text2 = f"[{time_val.strftime('%H:%M:%S')}]\nS3: {s3}°C\nS4: {s4}°C\nΔT: {d2:.1f}°C"

        if self.cursor_text2 and self.cursor_text2 in self.ax2.texts:
            self.cursor_text2.set_text(text2)
            self.cursor_text2.set_x(time_val)
        else:
             props = dict(boxstyle='round', facecolor='white', alpha=0.9, edgecolor='gray')
             trans = transforms.blended_transform_factory(self.ax2.transData, self.ax2.transAxes)
             self.cursor_text2 = self.ax2.text(time_val, 0.95, text2, transform=trans,
                                               verticalalignment='top', horizontalalignment='left',
                                               bbox=props, fontsize=9, zorder=10)

        self.canvas.draw_idle()

def main():
    print("Tkinter 초기화 중...")
    try:
        root = tk.Tk()
        print("Tkinter 초기화 완료.")
    except Exception as e:
        print(f"Tkinter 초기화 실패: {e}")
        return

    root.withdraw()

    print("폴더 선택 다이얼로그 대기 중...")
    selected_dir = filedialog.askdirectory(
        title="로그 데이터 폴더를 선택하세요",
        initialdir=DEFAULT_LOG_DIR,
        mustexist=True
    )

    if not selected_dir:
        print("폴더 선택이 취소되었습니다.")
        root.destroy()
        return

    print(f"선택된 폴더: {selected_dir}")
    root.deiconify()
    app = LogPlayerApp(root, selected_dir)
    print("메인 루프 시작.")
    root.mainloop()

if __name__ == "__main__":
    main()
