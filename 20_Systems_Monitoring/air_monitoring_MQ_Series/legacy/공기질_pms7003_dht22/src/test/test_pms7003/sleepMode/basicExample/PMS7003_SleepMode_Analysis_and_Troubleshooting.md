# PMS7003 슬립 모드 구현 기술 분석 및 트러블슈팅

본 문서는 PMS7003 먼지 센서의 슬립 모드(Sleep Mode) 제어 기능을 구현하는 과정에서 발생한 문제점과 해결 방법, 그리고 슬립 모드 진입을 위한 기술적 선행 조건을 정리한 문서입니다.

## 1. 슬립 모드(Sleep Mode) 진입을 위한 선행 조건 분석

PMS7003 센서를 단순히 `CMD_SLEEP` 명령만 보낸다고 해서 항상 팬(Fan)이 멈추고 절전 모드로 들어가는 것은 아닙니다. 안정적인 제어를 위해 다음과 같은 조건과 시퀀스가 필요합니다.

### 1.1. 하드웨어 연결 필수 조건 (RX/TX)
*   **현상:** 코드는 정상적으로 업로드되었으나 센서가 명령에 반응하지 않음.
*   **원인:** 보통 먼지 센서 예제들은 데이터 수신만 다루므로 아두이노의 `RX`만 연결하는 경우가 많음. 하지만 슬립 모드 제어를 위해서는 아두이노가 센서에게 **명령(Command)**을 보내야 함.
*   **필수 조건:**
    *   **Arduino TX (Pin 1)** <---> **PMS7003 RX (Pin 4)** 연결 필수.
    *   **Arduino RX (Pin 0)** <---> **PMS7003 TX (Pin 5)** 연결 필수.
    *   (Uno R4 WiFi의 경우 `Serial1` 사용 시 Pin 1이 TX, Pin 0이 RX임)

### 1.2. 소프트웨어 프로토콜 시퀀스 (Active -> Passive -> Sleep)
*   **문제점:** `CMD_SLEEP` 명령을 바로 전송했을 때, 센서가 데이터를 뱉어내는 중(Active Mode)이라면 명령이 무시되거나 팬이 멈추지 않는 현상이 발생함.
*   **분석:** Active Mode에서는 센서가 200~800ms마다 데이터를 지속적으로 전송하므로, MCU가 보낸 명령 패킷과 충돌하거나 센서가 명령 처리 준비가 안 될 수 있음.
*   **해결 시퀀스:**
    1.  **Passive Mode 전환 (`CMD_PASSIVE_MODE`):** 먼저 센서를 패시브 모드로 전환하여 데이터 자동 전송을 멈추게 함. 이 상태에서 센서는 명령 대기 상태가 됨.
    2.  **안정화 대기 (`delay`):** 모드 전환 후 약 100ms 정도 대기.
    3.  **Sleep 명령 전송 (`CMD_SLEEP`):** 데이터 전송이 멈춘 상태에서 슬립 명령을 보내면 즉시 팬이 정지하고 절전 모드로 진입함.

```cpp
// 권장 시퀀스 코드 예시
sendCommand(CMD_PASSIVE_MODE, sizeof(CMD_PASSIVE_MODE)); // 1. 데이터 스트림 정지
delay(100);
sendCommand(CMD_SLEEP, sizeof(CMD_SLEEP));             // 2. 슬립 명령 전송
```

### 1.3. 웨이크업(Wake Up) 시퀀스
*   깨어날 때는 반대로 `CMD_WAKEUP`을 보낸 후, 다시 데이터를 자동으로 받기 위해 `CMD_ACTIVE_MODE`를 보내주어야 합니다.

---

## 2. 개발 중 발생한 문제점 및 트러블슈팅 (Troubleshooting)

### 2.1. 컴파일 에러: 함수 중첩 (Function Definition Not Allowed)
*   **에러 메시지:** `a function-definition is not allowed here before '{' token`
*   **원인:** `showMenu()` 함수 내부에서 `handleInput()` 함수를 정의하려고 시도함. C/C++ 언어 특성상 함수 내부에 함수를 정의(Nested Function)하는 것은 표준에서 허용하지 않음.
*   **해결:** `handleInput()` 함수를 `showMenu()` 밖으로 꺼내어 전역 함수로 선언하고 구현함.

### 2.2. 변수 스코프(Scope) 및 선언 문제
*   **에러 메시지:** `'handleInput' was not declared in this scope`, `'lastStateChangeTim' was not declared`
*   **원인:**
    1.  함수 위치를 옮기면서 호출하는 곳보다 정의가 뒤에 있거나, 중괄호(`}`)가 잘못 닫혀 함수 범위가 꼬임.
    2.  오타(`lastStateChangeTim`)로 인한 변수 인식 불가.
    3.  복사/붙여넣기 과정에서 `sleepSensor()` 함수 끝부분에 의미 없는 코드 조각이 남음.
*   **해결:**
    *   함수 정의 순서 재배치 및 오타 수정.
    *   불필요한 코드 조각 삭제 및 문법 검증.

### 2.3. 비차단(Non-blocking) UI 구현 이슈
*   **요구사항:** 초기 40초 대기 시간 동안 카운트다운을 보여주면서, 사용자가 입력하면 즉시 반응해야 함.
*   **문제:** `delay(40000)`을 사용하면 40초 동안 아무런 입력도 받을 수 없음.
*   **해결:** `millis()`를 사용하여 현재 시간과 시작 시간의 차이를 계산하는 `while` 루프를 구현.
    *   1초마다 화면 갱신 (카운트다운).
    *   `Serial.available()`을 지속적으로 체크하여 입력 감지 시 루프 탈출(`break`).

## 3. 최종 구현된 시스템 동작 흐름

1.  **부팅:** 시스템 시작 및 메뉴 출력.
2.  **초기 설정 대기 (40초):**
    *   사용자 입력 대기 (1, 3, 5, 10, 20분 선택).
    *   입력 없으면 기본값(1분) 설정.
3.  **Wake Up & 측정 (30초):**
    *   센서 깨움 -> Active Mode 전환.
    *   2초 간격으로 미세먼지 데이터 출력.
4.  **Sleep 진입:**
    *   30초 경과 후 Passive Mode 전환 -> Sleep 명령 전송 (팬 정지).
5.  **Sleep 대기 (설정된 시간):**
    *   10초 간격으로 남은 휴식 시간 카운트다운.
    *   이 기간에도 사용자 입력으로 휴식 시간 변경 가능.
6.  **반복:** 설정된 시간 경과 후 다시 3번(Wake Up)으로 돌아감.
